"""This file contains auto-generated documentation extracted
from python run-time information. It is analyzed by KDevelop
to offer features such as code-completion and syntax highlighting.
If you discover errors in KDevelop's support for this module,
you can edit this file to correct the errors, e.g. you can add
additional return statements to functions to control the return
type to be used for that function by the analyzer.
Make sure to keep a copy of your changes so you don't accidentally
overwrite them by re-generating the file.
If you do significant improvements, consider sharing the file
with others through the Settings -> Configure KDevelop -> Python Documentation data
module!"""

def Buffer(_):
    """None"""
    return None
CONSTANT_CLASSES = list()
def CommandQueue(_):
    """None"""
    return None
class CompilerWarning:
    def __delattr__(self, name):
        """x.__delattr__('name') <==> del x.name"""
        return None
    __dict__ = dictproxy()
    __doc__ = None
    def __format__(self, _):
        """default object formatter"""
        return None
    def __getattribute__(self, name):
        """x.__getattribute__('name') <==> x.name"""
        return None
    def __getitem__(self, y):
        """x.__getitem__(y) <==> x[y]"""
        return None
    def __getslice__(self, i, j):
        """x.__getslice__(i, j) <==> x[i:j]
                   
                   Use of negative indices is not supported."""
        return None
    def __hash__(self, _):
        """x.__hash__() <==> hash(x)"""
        return None
    def __init__(self, more_args):
        """x.__init__(...) initializes x; see help(type(x)) for signature"""
        return None
    __module__ = str()
    def __new__(self, S, more_args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T"""
        return a()
    def __reduce__(self, _):
        """None"""
        return None
    def __reduce_ex__(self, _):
        """helper for pickle"""
        return None
    def __repr__(self, _):
        """x.__repr__() <==> repr(x)"""
        return None
    def __setattr__(self, name, value):
        """x.__setattr__('name', value) <==> x.name = value"""
        return None
    def __setstate__(self, _):
        """None"""
        return None
    def __sizeof__(self, _):
        """__sizeof__() -> int
        size of object in memory, in bytes"""
        return int()
    def __str__(self, _):
        """x.__str__() <==> str(x)"""
        return None
    def __sub_classhook__(self, _):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """
        return bool()
    def __unicode__(self, _):
        """None"""
        return None
    __weakref__ = getset_descriptor()
    args = getset_descriptor()
    message = getset_descriptor()
def Context(_):
    """None"""
    return None
DTYPE_TO_CHANNEL_TYPE = dict()
DTYPE_TO_CHANNEL_TYPE_NORM = dict()
def Device(_):
    """None"""
    return None
class Error:
    def __delattr__(self, name):
        """x.__delattr__('name') <==> del x.name"""
        return None
    __dict__ = dictproxy()
    __doc__ = None
    def __format__(self, _):
        """default object formatter"""
        return None
    def __getattribute__(self, name):
        """x.__getattribute__('name') <==> x.name"""
        return None
    def __getitem__(self, y):
        """x.__getitem__(y) <==> x[y]"""
        return None
    def __getslice__(self, i, j):
        """x.__getslice__(i, j) <==> x[i:j]
                   
                   Use of negative indices is not supported."""
        return None
    def __hash__(self, _):
        """x.__hash__() <==> hash(x)"""
        return None
    def __init__(self, more_args):
        """x.__init__(...) initializes x; see help(type(x)) for signature"""
        return None
    __module__ = str()
    def __new__(self, S, more_args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T"""
        return a()
    def __reduce__(self, _):
        """None"""
        return None
    def __reduce_ex__(self, _):
        """helper for pickle"""
        return None
    def __repr__(self, _):
        """x.__repr__() <==> repr(x)"""
        return None
    def __setattr__(self, name, value):
        """x.__setattr__('name', value) <==> x.name = value"""
        return None
    def __setstate__(self, _):
        """None"""
        return None
    def __sizeof__(self, _):
        """__sizeof__() -> int
        size of object in memory, in bytes"""
        return int()
    def error_str(self, _):
        """None"""
        return None
    def __sub_classhook__(self, _):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """
        return bool()
    def __unicode__(self, _):
        """None"""
        return None
    __weakref__ = getset_descriptor()
    args = getset_descriptor()
    code = property()
    message = getset_descriptor()
    routine = property()
    what = property()
def Event(_):
    """None"""
    return None
def Image(_):
    """None"""
    return None
def ImageDescriptor(_):
    """None"""
    return None
def ImageFormat(_):
    """None"""
    return None
def Kernel(_):
    """None"""
    return None
def LocalMemory(_):
    """None"""
    return None
class LogicError:
    def __delattr__(self, name):
        """x.__delattr__('name') <==> del x.name"""
        return None
    __dict__ = dictproxy()
    __doc__ = None
    def __format__(self, _):
        """default object formatter"""
        return None
    def __getattribute__(self, name):
        """x.__getattribute__('name') <==> x.name"""
        return None
    def __getitem__(self, y):
        """x.__getitem__(y) <==> x[y]"""
        return None
    def __getslice__(self, i, j):
        """x.__getslice__(i, j) <==> x[i:j]
                   
                   Use of negative indices is not supported."""
        return None
    def __hash__(self, _):
        """x.__hash__() <==> hash(x)"""
        return None
    def __init__(self, more_args):
        """x.__init__(...) initializes x; see help(type(x)) for signature"""
        return None
    __module__ = str()
    def __new__(self, S, more_args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T"""
        return a()
    def __reduce__(self, _):
        """None"""
        return None
    def __reduce_ex__(self, _):
        """helper for pickle"""
        return None
    def __repr__(self, _):
        """x.__repr__() <==> repr(x)"""
        return None
    def __setattr__(self, name, value):
        """x.__setattr__('name', value) <==> x.name = value"""
        return None
    def __setstate__(self, _):
        """None"""
        return None
    def __sizeof__(self, _):
        """__sizeof__() -> int
        size of object in memory, in bytes"""
        return int()
    def error_str(self, _):
        """None"""
        return None
    def __sub_classhook__(self, _):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """
        return bool()
    def __unicode__(self, _):
        """None"""
        return None
    __weakref__ = getset_descriptor()
    args = getset_descriptor()
    code = property()
    message = getset_descriptor()
    routine = property()
    what = property()
class MemoryError:
    def __delattr__(self, name):
        """x.__delattr__('name') <==> del x.name"""
        return None
    __dict__ = dictproxy()
    __doc__ = None
    def __format__(self, _):
        """default object formatter"""
        return None
    def __getattribute__(self, name):
        """x.__getattribute__('name') <==> x.name"""
        return None
    def __getitem__(self, y):
        """x.__getitem__(y) <==> x[y]"""
        return None
    def __getslice__(self, i, j):
        """x.__getslice__(i, j) <==> x[i:j]
                   
                   Use of negative indices is not supported."""
        return None
    def __hash__(self, _):
        """x.__hash__() <==> hash(x)"""
        return None
    def __init__(self, more_args):
        """x.__init__(...) initializes x; see help(type(x)) for signature"""
        return None
    __module__ = str()
    def __new__(self, S, more_args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T"""
        return a()
    def __reduce__(self, _):
        """None"""
        return None
    def __reduce_ex__(self, _):
        """helper for pickle"""
        return None
    def __repr__(self, _):
        """x.__repr__() <==> repr(x)"""
        return None
    def __setattr__(self, name, value):
        """x.__setattr__('name', value) <==> x.name = value"""
        return None
    def __setstate__(self, _):
        """None"""
        return None
    def __sizeof__(self, _):
        """__sizeof__() -> int
        size of object in memory, in bytes"""
        return int()
    def error_str(self, _):
        """None"""
        return None
    def __sub_classhook__(self, _):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """
        return bool()
    def __unicode__(self, _):
        """None"""
        return None
    __weakref__ = getset_descriptor()
    args = getset_descriptor()
    code = property()
    message = getset_descriptor()
    routine = property()
    what = property()
def MemoryMap(_):
    """None"""
    return None
def MemoryObject(_):
    """None"""
    return None
def MemoryObjectHolder(_):
    """None"""
    return None
def MemoryPool(_):
    """None"""
    return None
def NannyEvent(_):
    """None"""
    return None
def Platform(_):
    """None"""
    return None
def PooledBuffer(_):
    """None"""
    return None
class Program:
    def __delattr__(self, name):
        """x.__delattr__('name') <==> del x.name"""
        return None
    __dict__ = dictproxy()
    __doc__ = None
    def __eq__(self, _):
        """None"""
        return None
    def __format__(self, _):
        """default object formatter"""
        return None
    def __getattr__(self, _):
        """None"""
        return None
    def __getattribute__(self, name):
        """x.__getattribute__('name') <==> x.name"""
        return None
    def __hash__(self, _):
        """None"""
        return None
    def __init__(self, arg1="None", arg2="None", arg3="None"):
        """None"""
        return None
    __module__ = str()
    def __ne__(self, _):
        """None"""
        return None
    def __new__(self, S, more_args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T"""
        return a()
    def __reduce__(self, _):
        """helper for pickle"""
        return None
    def __reduce_ex__(self, _):
        """helper for pickle"""
        return None
    def __repr__(self, _):
        """x.__repr__() <==> repr(x)"""
        return None
    def __setattr__(self, name, value):
        """x.__setattr__('name', value) <==> x.name = value"""
        return None
    def __sizeof__(self, _):
        """__sizeof__() -> int
        size of object in memory, in bytes"""
        return int()
    def __str__(self, _):
        """x.__str__() <==> str(x)"""
        return None
    def __sub_classhook__(self, _):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """
        return bool()
    __weakref__ = getset_descriptor()
    def _build_and_catch_errors(self, build_func, options="None", source="None"):
        """None"""
        return None
    def _get_prg(self, _):
        """None"""
        return None
    def all_kernels(self, _):
        """None"""
        return None
    binaries = property()
    binary_sizes = property()
    def build(self="None", options="[]", devices="None", cache_dir="None"):
        """None"""
        return None
    def compile(self="[]", options="[]", devices="None", headers="[]"):
        """None"""
        return None
    context = property()
    devices = property()
    def _from_int_ptr(self, _):
        """
        from_int_ptr( (int)int_ptr_value) -> _Program :
            (static method) Return a new Python object referencing the C-level :c:type:`cl_program` object at the location pointed to by *int_ptr_value*. The relevant :c:func:`clRetain*` function will be called.
            
            .. versionadded:: 2013.2
            """
        return object()
    def get_build_info(self, _):
        """None"""
        return None
    def get_info(self, _):
        """None"""
        return None
    int_ptr = property()
    kernel_names = property()
    num_devices = property()
    num_kernels = property()
    reference_count = property()
    source = property()
class RuntimeError:
    def __delattr__(self, name):
        """x.__delattr__('name') <==> del x.name"""
        return None
    __dict__ = dictproxy()
    __doc__ = None
    def __format__(self, _):
        """default object formatter"""
        return None
    def __getattribute__(self, name):
        """x.__getattribute__('name') <==> x.name"""
        return None
    def __getitem__(self, y):
        """x.__getitem__(y) <==> x[y]"""
        return None
    def __getslice__(self, i, j):
        """x.__getslice__(i, j) <==> x[i:j]
                   
                   Use of negative indices is not supported."""
        return None
    def __hash__(self, _):
        """x.__hash__() <==> hash(x)"""
        return None
    def __init__(self, more_args):
        """x.__init__(...) initializes x; see help(type(x)) for signature"""
        return None
    __module__ = str()
    def __new__(self, S, more_args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T"""
        return a()
    def __reduce__(self, _):
        """None"""
        return None
    def __reduce_ex__(self, _):
        """helper for pickle"""
        return None
    def __repr__(self, _):
        """x.__repr__() <==> repr(x)"""
        return None
    def __setattr__(self, name, value):
        """x.__setattr__('name', value) <==> x.name = value"""
        return None
    def __setstate__(self, _):
        """None"""
        return None
    def __sizeof__(self, _):
        """__sizeof__() -> int
        size of object in memory, in bytes"""
        return int()
    def error_str(self, _):
        """None"""
        return None
    def __sub_classhook__(self, _):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """
        return bool()
    def __unicode__(self, _):
        """None"""
        return None
    __weakref__ = getset_descriptor()
    args = getset_descriptor()
    code = property()
    message = getset_descriptor()
    routine = property()
    what = property()
def Sampler(_):
    """None"""
    return None
def UserEvent(_):
    """None"""
    return None
VERSION = tuple()
VERSION_STATUS = str()
VERSION_TEXT = str()
_DEFAULT_BUILD_OPTIONS = list()
_DEFAULT_INCLUDE_OPTIONS = list()
_PLAT_BUILD_OPTIONS = dict()
__builtins__ = dict()
__copyright__ = str()
__doc__ = None
__file__ = str()
__license__ = str()
__name__ = str()
__package__ = str()
__path__ = list()
def _add_functionality():
    """None"""
    return None
_cl = module()
def create_some_context(interactive="None", answers="None"):
    """None"""
    return None
def _find_pyopencl_include_path():
    """None"""
    return None
_inspect = module()
def _mark_copy_deprecated(_):
    """None"""
    return None
def addressing_mode(_):
    """None"""
    return None
def affinity_domain_ext(_):
    """None"""
    return None
def bitlog2(_):
    """
    bitlog2( (int)arg1) -> int :
    
        C++ signature :
            unsigned int bitlog2(unsigned long)"""
    return None
def channel_order(_):
    """None"""
    return None
def channel_type(_):
    """None"""
    return None
def command_execution_status(_):
    """None"""
    return None
def command_queue_info(_):
    """None"""
    return None
def command_queue_properties(_):
    """None"""
    return None
def command_type(_):
    """None"""
    return None
def compiler_output(_):
    """None"""
    return None
def context_info(_):
    """None"""
    return None
def context_properties(_):
    """None"""
    return None
def create_program_with_built_in_kernels(_):
    """None"""
    return None
def create_some_context(interactive="None", answers="None"):
    """None"""
    return None
def device_affinity_domain(_):
    """None"""
    return None
def device_exec_capabilities(_):
    """None"""
    return None
def device_fp_config(_):
    """None"""
    return None
def device_info(_):
    """None"""
    return None
def device_local_mem_type(_):
    """None"""
    return None
def device_mem_cache_type(_):
    """None"""
    return None
def device_partition_property(_):
    """None"""
    return None
def device_partition_property_ext(_):
    """None"""
    return None
def device_type(_):
    """None"""
    return None
division = instance()
def enable_debugging(_):
    """Enables debugging for all code subsequently compiled by
        PyOpenCL on the passed *platform*. Alternatively, a context
        may be passed.
        """
    return None
def enqueue_barrier(queue="None", wait_for="None"):
    """None"""
    return None
def enqueue_copy(_):
    """Copy from :class:`Image`, :class:`Buffer` or the host to
        :class:`Image`, :class:`Buffer` or the host. (Note: host-to-host
        copies are unsupported.)
    
        The following keyword arguments are available:
    
        :arg wait_for: (optional, default empty)
        :arg is_blocking: Wait for completion. Defaults to *True*.
          (Available on any copy involving host memory)
    
        :return: A :class:`NannyEvent` if the transfer involved a
            host-side buffer, otherwise an :class:`Event`.
    
        .. ------------------------------------------------------------------------
        .. rubric :: Transfer :class:`Buffer` â host
        .. ------------------------------------------------------------------------
    
        :arg device_offset: offset in bytes (optional)
    
        .. note::
    
            The size of the transfer is controlled by the size of the
            of the host-side buffer. If the host-side buffer
            is a :class:`numpy.ndarray`, you can control the transfer size by
            transfering into a smaller 'view' of the target array, like this::
    
                cl.enqueue_copy(queue, large_dest_numpy_array[:15], src_buffer)
    
        .. ------------------------------------------------------------------------
        .. rubric :: Transfer :class:`Buffer` â :class:`Buffer`
        .. ------------------------------------------------------------------------
    
        :arg byte_count: (optional) If not specified, defaults to the
            size of the source in versions 2012.x and earlier,
            and to the minimum of the size of the source and target
            from 2013.1 on.
        :arg src_offset: (optional)
        :arg dest_offset: (optional)
    
        .. ------------------------------------------------------------------------
        .. rubric :: Rectangular :class:`Buffer` â  host transfers (CL 1.1 and newer)
        .. ------------------------------------------------------------------------
    
        :arg buffer_origin: :class:`tuple` of :class:`int` of length
            three or shorter. (mandatory)
        :arg host_origin: :class:`tuple` of :class:`int` of length
            three or shorter. (mandatory)
        :arg region: :class:`tuple` of :class:`int` of length
            three or shorter. (mandatory)
        :arg buffer_pitches: :class:`tuple` of :class:`int` of length
            two or shorter. (optional, "tightly-packed" if unspecified)
        :arg host_pitches: :class:`tuple` of :class:`int` of length
            two or shorter. (optional, "tightly-packed" if unspecified)
    
        .. ------------------------------------------------------------------------
        .. rubric :: Transfer :class:`Image` â host
        .. ------------------------------------------------------------------------
    
        :arg origin: :class:`tuple` of :class:`int` of length
            three or shorter. (mandatory)
        :arg region: :class:`tuple` of :class:`int` of length
            three or shorter. (mandatory)
        :arg pitches: :class:`tuple` of :class:`int` of length
            two or shorter. (optional)
    
        .. ------------------------------------------------------------------------
        .. rubric :: Transfer :class:`Buffer` â :class:`Image`
        .. ------------------------------------------------------------------------
    
        :arg offset: offset in buffer (mandatory)
        :arg origin: :class:`tuple` of :class:`int` of length
            three or shorter. (mandatory)
        :arg region: :class:`tuple` of :class:`int` of length
            three or shorter. (mandatory)
    
        .. ------------------------------------------------------------------------
        .. rubric :: Transfer :class:`Image` â :class:`Image`
        .. ------------------------------------------------------------------------
    
        :arg src_origin: :class:`tuple` of :class:`int` of length
            three or shorter. (mandatory)
        :arg dest_origin: :class:`tuple` of :class:`int` of length
            three or shorter. (mandatory)
        :arg region: :class:`tuple` of :class:`int` of length
            three or shorter. (mandatory)
    
        |std-enqueue-blurb|
    
        .. versionadded:: 2011.1
        """
    return None
def _enqueue_copy_buffer():
    """
    _enqueue_copy_buffer( (CommandQueue)queue, (MemoryObjectHolder)src, (MemoryObjectHolder)dst [, (int)byte_count=-1 [, (int)src_offset=0 [, (int)dst_offset=0 [, (object)wait_for=None]]]]) -> Event"""
    return None
def _enqueue_copy_buffer_rect():
    """
    _enqueue_copy_buffer_rect( (CommandQueue)queue, (MemoryObjectHolder)src, (MemoryObjectHolder)dst, (object)src_origin, (object)dst_origin, (object)region [, (object)src_pitches=None [, (object)dst_pitches=None [, (object)wait_for=None]]]) -> Event"""
    return None
def _enqueue_copy_buffer_to_image():
    """
    _enqueue_copy_buffer_to_image( (CommandQueue)queue, (MemoryObjectHolder)src, (MemoryObjectHolder)dest, (int)offset, (object)origin, (object)region [, (object)wait_for=None]) -> Event"""
    return None
def _enqueue_copy_image():
    """
    _enqueue_copy_image( (CommandQueue)queue, (MemoryObjectHolder)src, (MemoryObjectHolder)dest, (object)src_origin, (object)dest_origin, (object)region [, (object)wait_for=None]) -> Event"""
    return None
def _enqueue_copy_image_to_buffer():
    """
    _enqueue_copy_image_to_buffer( (CommandQueue)queue, (MemoryObjectHolder)src, (MemoryObjectHolder)dest, (object)origin, (object)region, (int)offset [, (object)wait_for=None]) -> Event"""
    return None
def enqueue_fill_buffer(queue, mem, pattern, offset, size="None", wait_for="None"):
    """None"""
    return None
def enqueue_fill_image(_):
    """
    enqueue_fill_image( (CommandQueue)arg1, (Image)arg2, (object)arg3, (object)queue, (object)mem, (int)color, (int)origin, (object)region [, (bool)wait_for=None]) -> Event"""
    return None
def enqueue_map_buffer(_):
    """
    enqueue_map_buffer( (CommandQueue)queue, (MemoryObjectHolder)buf, (int)flags, (int)offset, (object)shape, (object)dtype [, (object)order='C' [, (object)strides=None [, (object)wait_for=None [, (bool)is_blocking=True]]]]) -> object"""
    return None
def enqueue_map_image(_):
    """
    enqueue_map_image( (CommandQueue)queue, (MemoryObjectHolder)img, (int)flags, (object)origin, (object)region, (object)shape, (object)dtype [, (object)order='C' [, (object)strides=None [, (object)wait_for=None [, (bool)is_blocking=True]]]]) -> object"""
    return None
def enqueue_marker(queue="None", wait_for="None"):
    """None"""
    return None
def enqueue_migrate_mem_objects(_):
    """
    enqueue_migrate_mem_objects( (CommandQueue)queue, (object)mem_objects [, (int)flags=0 [, (object)wait_for=None]]) -> Event"""
    return None
def enqueue_nd_range_kernel(_):
    """
    enqueue_nd_range_kernel( (CommandQueue)queue, (Kernel)kernel, (object)global_work_size, (object)local_work_size [, (object)global_work_offset=None [, (object)wait_for=None [, (bool)g_times_l=False]]]) -> Event"""
    return None
def _enqueue_read_buffer():
    """
    _enqueue_read_buffer( (CommandQueue)queue, (MemoryObjectHolder)mem, (object)hostbuf [, (int)device_offset=0 [, (object)wait_for=None [, (bool)is_blocking=True]]]) -> Event"""
    return None
def _enqueue_read_buffer_rect():
    """
    _enqueue_read_buffer_rect( (CommandQueue)queue, (MemoryObjectHolder)mem, (object)hostbuf, (object)buffer_origin, (object)host_origin, (object)region [, (object)buffer_pitches=None [, (object)host_pitches=None [, (object)wait_for=None [, (bool)is_blocking=True]]]]) -> Event"""
    return None
def _enqueue_read_image():
    """
    _enqueue_read_image( (CommandQueue)queue, (Image)mem, (object)origin, (object)region, (object)hostbuf [, (int)row_pitch=0 [, (int)slice_pitch=0 [, (object)wait_for=None [, (bool)is_blocking=True]]]]) -> Event"""
    return None
def enqueue_task(_):
    """
    enqueue_task( (CommandQueue)queue, (Kernel)kernel [, (object)wait_for=None]) -> Event"""
    return None
def _enqueue_write_buffer():
    """
    _enqueue_write_buffer( (CommandQueue)queue, (MemoryObjectHolder)mem, (object)hostbuf [, (int)device_offset=0 [, (object)wait_for=None [, (bool)is_blocking=True]]]) -> Event"""
    return None
def _enqueue_write_buffer_rect():
    """
    _enqueue_write_buffer_rect( (CommandQueue)queue, (MemoryObjectHolder)mem, (object)hostbuf, (object)buffer_origin, (object)host_origin, (object)region [, (object)buffer_pitches=None [, (object)host_pitches=None [, (object)wait_for=None [, (bool)is_blocking=True]]]]) -> Event"""
    return None
def _enqueue_write_image():
    """
    _enqueue_write_image( (CommandQueue)queue, (Image)mem, (object)origin, (object)region, (object)hostbuf [, (int)row_pitch=0 [, (int)slice_pitch=0 [, (object)wait_for=None [, (bool)is_blocking=True]]]]) -> Event"""
    return None
def event_info(_):
    """None"""
    return None
def filter_mode(_):
    """None"""
    return None
def get_cl_header_version(_):
    """
    get_cl_header_version() -> tuple"""
    return None
def get_platforms(_):
    """
    get_platforms() -> list"""
    return None
def get_supported_image_formats(_):
    """
    get_supported_image_formats( (Context)arg1, (int)arg2, (int)arg3) -> list"""
    return None
def gl_context_info(_):
    """None"""
    return None
def have_gl(_):
    """
    have_gl() -> bool"""
    return None
def image__from_array(ctx, ary="False", num_channels="None", mode="r", norm_int="False"):
    """None"""
    return None
def image_info(_):
    """None"""
    return None
def kernel_arg_access_qualifier(_):
    """None"""
    return None
def kernel_arg_address_qualifier(_):
    """None"""
    return None
def kernel_arg_info(_):
    """None"""
    return None
def kernel_info(_):
    """None"""
    return None
def kernel_work_group_info(_):
    """None"""
    return None
def link_program(context, programs="None", options="[]", devices="None"):
    """None"""
    return None
def map_flags(_):
    """None"""
    return None
def mem_flags(_):
    """None"""
    return None
def mem_info(_):
    """None"""
    return None
def mem_migration_flags(_):
    """None"""
    return None
def mem_object_type(_):
    """None"""
    return None
def migrate_mem_object_flags_ext(_):
    """None"""
    return None
name = str()
np = module()
def platform_info(_):
    """None"""
    return None
def profiling_info(_):
    """None"""
    return None
def program_binary_type(_):
    """None"""
    return None
def program_build_info(_):
    """None"""
    return None
def program_info(_):
    """None"""
    return None
class program_kind:
    BINARY = program_kind()
    SOURCE = program_kind()
    UNKNOWN = program_kind()
    def __abs__(self, _):
        """x.__abs__() <==> abs(x)"""
        return None
    def __add__(self, y):
        """x.__add__(y) <==> x+y"""
        return None
    def __and__(self, y):
        """x.__and__(y) <==> x&y"""
        return None
    def __cmp__(self, y):
        """x.__cmp__(y) <==> cmp(x,y)"""
        return None
    def __coerce__(self, y):
        """x.__coerce__(y) <==> coerce(x, y)"""
        return None
    def __delattr__(self, name):
        """x.__delattr__('name') <==> del x.name"""
        return None
    def __div__(self, y):
        """x.__div__(y) <==> x/y"""
        return None
    def __divmod__(self, y):
        """x.__divmod__(y) <==> divmod(x, y)"""
        return None
    __doc__ = None
    def __float__(self, _):
        """x.__float__() <==> float(x)"""
        return None
    def __floordiv__(self, y):
        """x.__floordiv__(y) <==> x//y"""
        return None
    def __format__(self, _):
        """None"""
        return None
    def __getattribute__(self, name):
        """x.__getattribute__('name') <==> x.name"""
        return None
    def __getnewargs__(self, _):
        """None"""
        return None
    def __hash__(self, _):
        """x.__hash__() <==> hash(x)"""
        return None
    def __hex__(self, _):
        """x.__hex__() <==> hex(x)"""
        return None
    def __index__(self, _):
        """x[y:z] <==> x[y.__index__():z.__index__()]"""
        return None
    def __init__(self, more_args):
        """x.__init__(...) initializes x; see help(type(x)) for signature"""
        return None
    def __int__(self, _):
        """x.__int__() <==> int(x)"""
        return None
    def __invert__(self, _):
        """x.__invert__() <==> ~x"""
        return None
    def __long__(self, _):
        """x.__long__() <==> long(x)"""
        return None
    def __lshift__(self, y):
        """x.__lshift__(y) <==> x<<y"""
        return None
    def __mod__(self, y):
        """x.__mod__(y) <==> x%y"""
        return None
    __module__ = str()
    def __mul__(self, y):
        """x.__mul__(y) <==> x*y"""
        return None
    def __neg__(self, _):
        """x.__neg__() <==> -x"""
        return None
    def __new__(self, S, more_args):
        """T.__new__(S, ...) -> a new object with type S, a subtype of T"""
        return a()
    def __nonzero__(self, _):
        """x.__nonzero__() <==> x != 0"""
        return None
    def __oct__(self, _):
        """x.__oct__() <==> oct(x)"""
        return None
    def __or__(self, y):
        """x.__or__(y) <==> x|y"""
        return None
    def __pos__(self, _):
        """x.__pos__() <==> +x"""
        return None
    def __pow__(self, y, z=None):
        """x.__pow__(y[, z]) <==> pow(x, y[, z])"""
        return None
    def __radd__(self, y):
        """x.__radd__(y) <==> y+x"""
        return None
    def __rand__(self, y):
        """x.__rand__(y) <==> y&x"""
        return None
    def __rdiv__(self, y):
        """x.__rdiv__(y) <==> y/x"""
        return None
    def __rdivmod__(self, y):
        """x.__rdivmod__(y) <==> divmod(y, x)"""
        return None
    def __reduce__(self, _):
        """helper for pickle"""
        return None
    def __reduce_ex__(self, _):
        """helper for pickle"""
        return None
    def __repr__(self, _):
        """x.__repr__() <==> repr(x)"""
        return None
    def __rfloordiv__(self, y):
        """x.__rfloordiv__(y) <==> y//x"""
        return None
    def __rlshift__(self, y):
        """x.__rlshift__(y) <==> y<<x"""
        return None
    def __rmod__(self, y):
        """x.__rmod__(y) <==> y%x"""
        return None
    def __rmul__(self, y):
        """x.__rmul__(y) <==> y*x"""
        return None
    def __ror__(self, y):
        """x.__ror__(y) <==> y|x"""
        return None
    def __rpow__(self, x, z=None):
        """y.__rpow__(x[, z]) <==> pow(x, y[, z])"""
        return None
    def __rrshift__(self, y):
        """x.__rrshift__(y) <==> y>>x"""
        return None
    def __rshift__(self, y):
        """x.__rshift__(y) <==> x>>y"""
        return None
    def __rsub__(self, y):
        """x.__rsub__(y) <==> y-x"""
        return None
    def __rtruediv__(self, y):
        """x.__rtruediv__(y) <==> y/x"""
        return None
    def __rxor__(self, y):
        """x.__rxor__(y) <==> y^x"""
        return None
    def __setattr__(self, name, value):
        """x.__setattr__('name', value) <==> x.name = value"""
        return None
    def __sizeof__(self, _):
        """__sizeof__() -> int
        size of object in memory, in bytes"""
        return int()
    __slots__ = tuple()
    def __str__(self, _):
        """x.__str__() <==> str(x)"""
        return None
    def __sub__(self, y):
        """x.__sub__(y) <==> x-y"""
        return None
    def __sub_classhook__(self, _):
        """Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        """
        return bool()
    def __truediv__(self, y):
        """x.__truediv__(y) <==> x/y"""
        return None
    def __trunc__(self, _):
        """Truncating an Integral returns itself."""
        return None
    def __xor__(self, y):
        """x.__xor__(y) <==> x^y"""
        return None
    def bit_length(self, _):
        """int.bit_length() -> int
        
        Number of bits necessary to represent self in binary.
        >>> bin(37)
        '0b100101'
        >>> (37).bit_length()
        6"""
        return int()
    def conjugate(self, _):
        """Returns self, the complex conjugate of any int."""
        return complex()
    denominator = getset_descriptor()
    imag = getset_descriptor()
    name = member_descriptor()
    names = dict()
    numerator = getset_descriptor()
    real = getset_descriptor()
    def to_string(cls, value="None", default_format="None"):
        """None"""
        return None
    values = dict()
def sampler_info(_):
    """None"""
    return None
def status_code(_):
    """None"""
    return None
def unload_platform_compiler(_):
    """
    unload_platform_compiler( (Platform)arg1) -> None"""
    return None
version = module()
def wait_for_events(_):
    """
    wait_for_events( (object)arg1) -> None"""
    return None
